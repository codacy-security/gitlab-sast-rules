# yamllint disable
# rule-set version: v1.3.41
# yamllint enable
---
rules:
- id: "bandit.B101"
  languages:
  - "python"
  message: |
    The application was found using `assert` in non-test code. Usually reserved for debug and test
    code, the `assert`
    function is commonly used to test conditions before continuing execution. However, enclosed
    code will be removed
    when compiling Python code to optimized byte code. Depending on the assertion and subsequent
    logic, this could
    lead to undefined behavior of the application or application crashes.

    To remediate this issue, remove the `assert` calls. If necessary, replace them with either `if`
    conditions or
    `try/except` blocks.

    Example using `try/except` instead of `assert`:
    ```
    # Below try/except is equal to the assert statement of:
    # assert user.is_authenticated(), "user must be authenticated"
    try:
        if not user.is_authenticated():
            raise AuthError("user must be authenticated")
    except AuthError as e:
        # Handle error
        # ...
        # Return, do not continue processing
        return
    ```
  metadata:
    cwe: "CWE-754"
    category: "security"
    shortDescription: "Improper check for unusual or exceptional conditions"
    license: "MIT"
    primary_identifier: "bandit.B101"
    secondary_identifiers:
    - name: "Bandit Test ID B101"
      type: "bandit_test_id"
      value: "B101"
  patterns:
  - pattern: "assert(...)"
  - pattern-not-inside: |
      import pytest
      ...
  - pattern-not-inside: |
      import unittest
      ...
  severity: "INFO"
- id: "bandit.B412"
  languages:
  - "python"
  message: |
    Consider possible security implications associated with httpoxy module.
  metadata:
    cwe: "CWE-284"
    owasp: "A5:2017-Broken Access Control"
    shortDescription: "Improper Access Control"
    license: "MIT"
    primary_identifier: "bandit.B412"
    secondary_identifiers:
    - name: "Bandit Test ID B412"
      type: "bandit_test_id"
      value: "B412"
  pattern-either:
  - pattern: "wsgiref.handlers.CGIHandler(...)"
  - pattern: "twisted.web.twcgi.CGIDirectory(...)"
  severity: "ERROR"
- id: "bandit.B413"
  languages:
  - "python"
  message: |
    The application was detected importing `pycrypto`. This package has been deprecated as it
    contains
    security vulnerabilities.

    To remediate this issue, consider using the [cryptography](https://cryptography.io/)
    package instead.
  metadata:
    cwe: "CWE-1104"
    owasp: "A9:2017-Using Components with Known Vulnerabilities"
    category: "security"
    shortDescription: "Use of unmaintained third party components"
    license: "MIT"
    primary_identifier: "bandit.B413"
    secondary_identifiers:
    - name: "Bandit Test ID B413"
      type: "bandit_test_id"
      value: "B413"
  pattern-either:
  - pattern: "import pycryto"
  - pattern: "import Crypto.Cipher"
  - pattern: "import Crypto.Hash"
  - pattern: "import Crypto.IO"
  - pattern: "import Crypto.Protocol"
  - pattern: "import Crypto.PublicKey"
  - pattern: "import Crypto.Random"
  - pattern: "import Crypto.Signature"
  - pattern: "import Crypto.Util"
  severity: "ERROR"
- id: "bandit.B415"
  languages:
  - "python"
  pattern-either:
  - pattern: "import pyghmi"
  message: |
    An IPMI-related module is being imported. IPMI is considered insecure. Use an encrypted
    protocol.
  metadata:
    shortDescription: "Cryptographic issues"
    cwe: "CWE-310"
    category: "security"
    cisa: "https://www.cisa.gov/uscert/ncas/alerts/TA13-207A"
    license: "MIT"
    primary_identifier: "bandit.B415"
    secondary_identifiers:
    - name: "Bandit Test ID B415"
      type: "bandit_test_id"
      value: "B415"
  severity: "ERROR"
- id: "bandit.B506"
  languages:
  - "python"
  message: |
    The application was found using an unsafe version of `yaml` load which is vulnerable to
    deserialization attacks. Deserialization attacks exploit the process of reading serialized
    data and turning it back
    into an object. By constructing malicious objects and serializing them, an adversary may
    attempt to:

    - Inject code that is executed upon object construction, which occurs during the
    deserialization process.
    - Exploit mass assignment by including fields that are not normally a part of the serialized
    data but are read in during deserialization.

    To remediate this issue, use `safe_load()` or call `yaml.load()` with the `Loader` argument
    set to
    `yaml.SafeLoader`.

    Example loading YAML using `safe_load`:
    ```
    import yaml

    # Use safe_load to load data into an intermediary object
    intermediary_object = yaml.safe_load("""user:
        name: 'test user'"""
    )
    # Create our real object, copying over only the necessary fields
    user_object = {'user': {
            # Assign the deserialized data from intermediary object
            'name': intermediary_object['user']['name'],
            # Add in protected data in object definition (or set it from a class constructor)
            'is_admin': False,
        }
    }
    # Work with user_object
    # ...
    ```

    For more details on deserialization attacks in general, see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    category: "security"
    shortDescription: "Deserialization of untrusted data"
    license: "MIT"
    primary_identifier: "bandit.B506"
    secondary_identifiers:
    - name: "Bandit Test ID B506"
      type: "bandit_test_id"
      value: "B506"
  patterns:
  - pattern-inside: |
      import yaml
      ...
  - pattern-not-inside: |
      from ruamel.yaml import YAML
      ...
  - pattern-either:
    - pattern: "yaml.unsafe_load(...)"
    - pattern: "yaml.$LD(..., Loader=yaml.$LOADER, ...)"
    - pattern: "yaml.$LD($DATA)"
  - metavariable-regex:
      metavariable: "$LOADER"
      regex: "(Loader|UnsafeLoader|CLoader|FullLoader)"
  - metavariable-regex:
      metavariable: "$LD"
      regex: "(load|load_all)"
  severity: "ERROR"
- id: "bandit.B610"
  languages:
  - "python"
  message: |
    SQL Injection is a critical vulnerability that can lead to data or system compromise. By
    dynamically generating SQL query strings, user input may be able to influence the logic of
    the SQL statement. This could lead to an adversary accessing information they should
    not have access to, or in some circumstances, being able to execute OS functionality or code.

    Replace all dynamically generated SQL queries with parameterized queries. In situations where
    dynamic queries must be created, never use direct user input, but instead use a map or
    dictionary of valid values and resolve them using a user supplied key.

    For example, some database drivers do not allow parameterized queries for `>` or `<` comparison
    operators. In these cases, do not use a user supplied `>` or `<` value, but rather have the
    user
    supply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`
    values to be used in the construction of the dynamic query. The same goes for other queries
    where
    column or table names are required but cannot be parameterized.

    The `QuerySet.extra` API method will be deprecated as it a source of SQL Injection
    vulnerabilities and other problems. This method is especially risky as callers
    will need to do their own escaping of any parameters that come from user-supplied
    information.

    To remediate this issue, do not use `extra` but use other `QuerySet` methods to achieve
    the same goals. If for some reason this is not feasible, consider using the `RawSQL` method
    and making sure that all arguments, including user-supplied ones, are only used in
    `params`


    While not recommended due to [potential SQL
    Injection](https://docs.djangoproject.com/en/4.2/ref/models/expressions/#raw-sql-expressions),
    below is an example using `RawSQL`,
    passing in user-supplied data as a `param` which will escape the input:
    ```
    # If dealing with integer based user input, restrict the values to integers only using the
    # path configuration: path('<int:user_supplied_id>/someview/', views.some_view,
    name='someview'),

    # views.py
    def some_view(request, user_supplied_id):
      # Never use string interpolation in the `sql` parameter.
      # Never quote the `%s` string format such as `... where id='%s'` as this could lead to SQL
    Injection.
      # Pass the user supplied data only in the `params` parameter.
      for obj in DBObject.objects.all().annotate(
          val=RawSQL(sql="select id from some_secondary_table where id=%s",
    params=[user_supplied_id])):
        # Work with the results from the query
        # ...
    ```

    For more information on QuerySet see:
    - https://docs.djangoproject.com/en/4.2/ref/models/querysets/#queryset-api

    For more information on SQL Injection see OWASP:
    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
  metadata:
    cwe: "CWE-89"
    owasp: "A1:2017-Injection"
    category: "security"
    shortDescription: "Improper neutralization of special elements used in an SQL
      Command ('SQL Injection')"
    license: "MIT"
    primary_identifier: "bandit.B610"
    secondary_identifiers:
    - name: "Bandit Test ID B610"
      type: "bandit_test_id"
      value: "B610"
  patterns:
  - pattern: "$X.objects. ... .extra(..., $K = $V, ...)"
  - pattern-not-inside: |
      $V = ['...']
      ...
  - metavariable-pattern:
      metavariable: "$V"
      patterns:
      - pattern: "$V"
      - pattern-not: "[..., '...', ...]"
      - pattern-not: "{..., '...': '...', ...}"
      - pattern-not: "\"...\""
      - pattern-not: "[..., \"...\" % \"...\", ...]"
      - pattern-not: "{..., $L: \"...\" % \"...\", ...}"
      - pattern-not: "{..., $L: \"...\".format(\"...\"), ...}"
      - pattern-not: "[..., \"...\".format(\"...\"), ...]"
  severity: "WARNING"
- id: "bandit.B611"
  languages:
  - "python"
  message: |
    SQL Injection is a critical vulnerability that can lead to data or system compromise. By
    dynamically generating SQL query strings, user input may be able to influence the logic of
    the SQL statement. This could lead to an adversary accessing information they should
    not have access to, or in some circumstances, being able to execute OS functionality or code.

    Replace all dynamically generated SQL queries with parameterized queries. In situations where
    dynamic queries must be created, never use direct user input, but instead use a map or
    dictionary of valid values and resolve them using a user supplied key.

    For example, some database drivers do not allow parameterized queries for `>` or `<` comparison
    operators. In these cases, do not use a user supplied `>` or `<` value, but rather have the
    user
    supply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`
    values to be used in the construction of the dynamic query. The same goes for other queries
    where
    column or table names are required but cannot be parameterized.

    To remediate this issue, do not use `raw` or `RawSQL` but use other `QuerySet` methods to
    achieve
    the same goals. If for some reason this is not feasible, ensure calls including user-supplied
    data
    pass it in to the `params` parameter of the `RawSQL` method.

    While not recommended due to [potential SQL
    Injection](https://docs.djangoproject.com/en/4.2/ref/models/expressions/#raw-sql-expressions),
    below is an example using `RawSQL`,
    passing in user-supplied data as a `param` which will escape the input:
    ```
    # If dealing with integer based user input, restrict the values to integers only using the
    # path configuration: path('<int:user_supplied_id>/someview/', views.some_view,
    name='someview'),

    # views.py
    def some_view(request, user_supplied_id):
      # Never use string interpolation in the `sql` parameter.
      # Never quote the `%s` string format such as `... where id='%s'` as this could lead to SQL
    Injection.
      # Pass the user supplied data only in the `params` parameter.
      for obj in DBObject.objects.all().annotate(
          val=RawSQL(sql="select id from some_secondary_table where id=%s",
    params=[user_supplied_id])):
        # Work with the results from the query
        # ...
    ```

    For more information on QuerySet see:
    - https://docs.djangoproject.com/en/4.2/ref/models/querysets/#queryset-api

    For more information on SQL Injection see OWASP:
    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
  metadata:
    cwe: "CWE-89"
    owasp: "A1:2017-Injection"
    category: "security"
    shortDescription: "Improper neutralization of special elements used in an SQL
      Command ('SQL Injection')"
    license: "MIT"
    primary_identifier: "bandit.B611"
    secondary_identifiers:
    - name: "Bandit Test ID B611"
      type: "bandit_test_id"
      value: "B611"
  patterns:
  - pattern-either:
    - pattern: "$MODEL.objects.raw($QUERY, ...)"
    - pattern: "django.db.models.expressions.RawSQL(...)"
  severity: "ERROR"
- id: "bandit.B703"
  languages:
  - "python"
  message: |
    `mark_safe()` is used to mark a string as `safe` for HTML output.
    This disables escaping and could therefore subject the content to
    XSS attacks. Use `django.utils.html.format_html()` to build HTML
    for rendering instead.
  metadata:
    cwe: "CWE-79"
    owasp: "A7:2017-Cross-Site Scripting (XSS)"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    license: "MIT"
    primary_identifier: "bandit.B703"
    secondary_identifiers:
    - name: "Bandit Test ID B703"
      type: "bandit_test_id"
      value: "B703"
  patterns:
  - pattern-not-inside: |-
      django.utils.html.format_html(...)
  - pattern-either:
    - patterns:
      - pattern: "django.utils.safestring.mark_safe(...)"
      - pattern-not: "django.utils.safestring.mark_safe(\"...\")"
  severity: "WARNING"
- id: "bandit.B112"
  languages:
  - "python"
  message: |
    Try, Except, Continue
  metadata:
    cwe: "CWE-703"
    shortDescription: "Improper Check or Handling of Exceptional Conditions"
    license: "MIT"
    primary_identifier: "bandit.B112"
    secondary_identifiers:
    - name: "Bandit Test ID B112"
      type: "bandit_test_id"
      value: "B112"
  pattern-either:
  - pattern: |
      try: ...
      except $EXCEPTION: continue
  - pattern: |
      try: ...
      except $EXCEPTION as $X: continue
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION: continue
  - pattern: |
      try: ...
      except $EXCEPTION: continue
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION as $X: continue
  - pattern: |
      try: ...
      except $EXCEPTION as $X: continue
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: continue
  - pattern: |
      try: ...
      except $EXCEPTION: continue
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION: continue
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: continue
  - pattern: |
      try: ...
      except $EXCEPTION as $X: continue
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION as $X: continue
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: continue
  - pattern: |
      try: ...
      except $EXCEPTION: continue
      except ... : ...
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION: continue
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: continue
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: continue
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: continue
  - pattern: |
      try: ...
      except $EXCEPTION as $X: continue
      except ... : ...
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION as $X: continue
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: continue
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: continue
  severity: "INFO"
- id: "bandit.B110"
  languages:
  - "python"
  message: |
    Try, Except, Pass
  metadata:
    cwe: "CWE-703"
    shortDescription: "Improper Check or Handling of Exceptional Conditions"
    license: "MIT"
    primary_identifier: "bandit.B110"
    secondary_identifiers:
    - name: "Bandit Test ID B110"
      type: "bandit_test_id"
      value: "B110"
  pattern-either:
  - pattern: |
      try: ...
      except $EXCEPTION: pass
  - pattern: |
      try: ...
      except $EXCEPTION as $X: pass
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION: pass
  - pattern: |
      try: ...
      except $EXCEPTION: pass
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION as $X: pass
  - pattern: |
      try: ...
      except $EXCEPTION as $X: pass
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: pass
  - pattern: |
      try: ...
      except $EXCEPTION: pass
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION: pass
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: pass
  - pattern: |
      try: ...
      except $EXCEPTION as $X: pass
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION as $X: pass
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: pass
  - pattern: |
      try: ...
      except $EXCEPTION: pass
      except ... : ...
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION: pass
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: pass
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION: pass
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: pass
  - pattern: |
      try: ...
      except $EXCEPTION as $X: pass
      except ... : ...
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except $EXCEPTION as $X: pass
      except ... : ...
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: pass
      except ... : ...
  - pattern: |
      try: ...
      except ... : ...
      except ... : ...
      except ... : ...
      except $EXCEPTION as $X: pass
  severity: "INFO"
- id: "bandit.B102"
  languages:
  - "python"
  message: |
    The application was found calling the `exec` function with a non-literal variable. If the
    variable comes from user-supplied input, an adversary could compromise the entire system by
    executing arbitrary python code.

    To remediate this issue, remove all calls to `exec` and consider alternative methods for
    executing
    the necessary business logic. There is almost no safe method of calling `eval` with
    user-supplied input.

    If the application only needs to convert strings into objects, consider using `json.loads`.
    In some cases `ast.literal_eval` is recommended, but this should be avoided as it can still
    suffer from other issues such as the ability for malicious code to crash the python
    interpreter or application.

    Example using `json.loads`` to load in arbitrary data to create data structures:
    ```
    # User supplied data as a blob of JSON
    user_supplied_data = """{"user": "test", "metadata": [1,2,3]}"""
    # Load the JSON
    user_object = json.loads(user_supplied_data)
    # Manually add protected properties _after_ loading, never before
    user_object["is_admin"] = False
    # Work with the object
    ```
  metadata:
    cwe: "CWE-78"
    owasp: "A1:2017-Injection"
    category: "security"
    shortDescription: "Improper neutralization of special elements used in an OS command
      ('OS Command Injection')"
    license: "MIT"
    primary_identifier: "bandit.B102"
    secondary_identifiers:
    - name: "Bandit Test ID B102"
      type: "bandit_test_id"
      value: "B102"
  patterns:
  - pattern: "exec(...)"
  - pattern-not: "exec(\"...\")"
  severity: "WARNING"
- id: "bandit.B607"
  languages:
  - "python"
  message: |
    Starting a process with a shell; seems safe, but may be changed in the future, consider
    rewriting without shell
  metadata:
    cwe: "CWE-78"
    owasp: "A1:2017-Injection"
    shortDescription: "Improper Neutralization of Special Elements used in an OS Command
      ('OS Command Injection')"
    license: "MIT"
    primary_identifier: "bandit.B607"
    secondary_identifiers:
    - name: "Bandit Test ID B607"
      type: "bandit_test_id"
      value: "B607"
  pattern-either:
  - pattern: "os.system(\"...\", ...)"
  - pattern: "$OS.popen(\"...\", ...)"
  - pattern: "$OS.popen2(\"...\", ...)"
  - pattern: "$OS.popen3(\"...\", ...)"
  - pattern: "$OS.popen4(\"...\", ...)"
  - pattern: "commands.getoutput(\"...\", ...)"
  - pattern: "commands.getstatusoutput(\"...\", ...)"
  severity: "INFO"
- id: "bandit.B605"
  languages:
  - "python"
  message: |
    Starting a process with a shell; seems safe, but may be changed in the future, consider
    rewriting without shell
  metadata:
    cwe: "CWE-78"
    owasp: "A1:2017-Injection"
    shortDescription: "Improper Neutralization of Special Elements used in an OS Command
      ('OS Command Injection')"
    license: "MIT"
    primary_identifier: "bandit.B605"
    secondary_identifiers:
    - name: "Bandit Test ID B605"
      type: "bandit_test_id"
      value: "B605"
  patterns:
  - pattern-either:
    - pattern: "os.system(...)"
    - pattern: "os.popen(...)"
    - pattern: "os.popen2(...)"
    - pattern: "os.popen3(...)"
    - pattern: "os.popen4(...)"
    - pattern: "popen2.popen2(...)"
    - pattern: "popen2.popen3(...)"
    - pattern: "popen2.popen4(...)"
    - pattern: "popen2.Popen3(...)"
    - pattern: "popen2.Popen4(...)"
    - pattern: "commands.getoutput(...)"
    - pattern: "commands.getstatusoutput(\"\")"
  severity: "INFO"
- id: "bandit.B603"
  languages:
  - "python"
  message: |
    Python possesses many mechanisms to invoke an external executable. However,
    doing so may present a security issue if appropriate care is not taken to
    sanitize any user provided or variable input. This plugin test is part of a
    family of tests built to check for process spawning and warn appropriately.
    Specifically, this test looks for the spawning of a subprocess without the
    use of a command shell. This type of subprocess invocation is not
    vulnerable to shell injection attacks, but care should still be taken to
    ensure validity of input.
  metadata:
    cwe: "CWE-78"
    owasp: "A1:2017-Injection"
    shortDescription: "Improper Neutralization of Special Elements used in an OS Command
      ('OS Command Injection')"
    license: "MIT"
    primary_identifier: "bandit.B603"
    secondary_identifiers:
    - name: "Bandit Test ID B603"
      type: "bandit_test_id"
      value: "B603"
  patterns:
  - pattern-not: "subprocess.$FUNC($ARG, shell=<... True ...>)"
  - pattern-not: "subprocess.$FUNC($ARG, shell=<... 'True' ...>)"
  - pattern-not: "subprocess.$FUNC($ARG, shell=<... \"True\" ...>)"
  - pattern-either:
    - pattern: |
        subprocess.$FUNC($ARG, shell=False)
    - pattern: |
        subprocess.$FUNC($ARG, shell=0)
    - pattern: |
        subprocess.$FUNC($ARG, shell={...})
    - pattern: |
        subprocess.$FUNC($ARG, shell=[...])
    - pattern: |
        subprocess.$FUNC($ARG)
  severity: "WARNING"
- id: "bandit.B604"
  languages:
  - "python"
  message: |
    subprocess call - check for execution of untrusted input
  metadata:
    cwe: "CWE-78"
    owasp: "A1:2017-Injection"
    shortDescription: "Improper Neutralization of Special Elements used in an OS Command
      ('OS Command Injection')"
    license: "MIT"
    primary_identifier: "bandit.B604"
    secondary_identifiers:
    - name: "Bandit Test ID B604"
      type: "bandit_test_id"
      value: "B604"
  patterns:
  - pattern-not: "subprocess.$FUNC(..., shell=True, ...)"
  - pattern: "$FOO(..., shell=True, ...)"
  severity: "WARNING"
- id: "bandit.B202"
  languages:
  - "python"
  message: |
    The application may be vulnerable to a path traversal if it extracts untrusted archive files.
    This vulnerability is colloquially known as 'Zip Slip'. Archive files may contain folders
    which,
    when extracted, may write outside of the intended directory. This is exploited by including
    path traversal characters such as `../../other/directory` to overwrite or place files in system
    or application directories.

    Extra care must be taken when extracting archive files as there are numerous concerns:

    - If possible, generate unique filenames instead of using the archives file names, as it may be
    possible for users to overwrite files if the filenames are the same.
    - Validate file paths are written with a prefixed, known trusted directory.
    - Only process regular files and not symbolic links, as some applications may attempt to
    read/follow
    the symbolic link, leading to arbitrary file read / write vulnerabilities.

    Example of securely processing an archive file:
    ```
    import tarfile
    import uuid
    # import os

    tar = tarfile.open('some.tar')

    # Max number of allowed files in our archive
    max_files = 10
    # Max size for all files in archive
    max_size = 1024 * 1024 * 10 # 10MB
    # Max size per file in archive
    max_file_size = 1024 * 1024 # 1MB

    # Validate number of files in archive
    if len(tar.getmembers()) > max_files:
        raise Exception("Too many files in archive")

    total_size = 0
    # Loop over all files to see if we exceed max size
    # if so, do not process any of them.
    for f in tar.getmembers():
        total_size += f.size
        if total_size >= max_size:
            raise Exception("Archive files exceeded max file size")

    # Iterate over files now that we know the total size is within limits
    for f in tar.getmembers():
        # Internally this calls TarInfo.isreg() which ensures
        # the file is a regular file and not a sym link or directory
        if not f.isfile():
            continue

        # Optional, set a limit on each file size
        if f.size > max_file_size:
            raise Exception(f"File {f.name} too large: {f.size}")

        # If original names are required, ensure that only the
        # filename is used:
        # filename = os.path.basename(f.name)

        # More secure, generate a UUID4 value instead
        filename = uuid.uuid4().hex

        # Reset the archive filename to the basename
        # Newer versions of python (3.11.4+) should use:
        # new_tar = old_tar.replace(name=...new name...)
        f.name = filename

        # Extract the file into a restricted directory, with our
        # own user's attributes, not the file from the archive
        tar.extract(f, '/opt/app/restricted/', set_attrs=False)
    ```

    For more information on tarfile see:
    - https://docs.python.org/3/library/tarfile.html
  metadata:
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    license: "MIT"
    primary_identifier: "bandit.B202"
    secondary_identifiers:
    - name: "Bandit Test ID B202"
      type: "bandit_test_id"
      value: "B202"
  patterns:
  - pattern-inside: |
      import tarfile
      ...
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $TAR = tarfile.open(...)
          ...
      - pattern-either:
        - pattern: "$TAR.extractall(...)"
        - pattern: "tarfile.extractall(..., members=$TAR)"
        - pattern: "$TAR.extractall(..., members=[])"
    - patterns:
      - pattern: "tarfile.extractall(...)"
      - pattern: "tarfile.extractall(..., members=[])"
  severity: "ERROR"
- id: "bandit.B402"
  languages:
  - "python"
  message: |
    functions are being called. FTP is considered insecure. Use SSH/SFTP/SCP orsome other encrypted
    protocol
  metadata:
    cwe: "CWE-319"
    owasp: "A3:2017-Sensitive Data Exposure"
    shortDescription: "Cleartext Transmission of Sensitive Information"
    license: "MIT"
    primary_identifier: "bandit.B402"
    secondary_identifiers:
    - name: "Bandit Test ID B402"
      type: "bandit_test_id"
      value: "B402"
  patterns:
  - pattern-either:
    - pattern: "import ftplib"
    - pattern: "from ftplib import FTP"
    - pattern: "ftplib.FTP(...)"
  severity: "ERROR"
- id: "bandit.B612"
  languages:
  - "python"
  message: |
    The application was found calling the `logging.config.listen`` function, which provides the
    ability to listen for
    external configuration files over a socket server. This listen socket parses part of the
    configuration and calls
    `eval` on the supplied configuration file. A local user, or an adversary who is able to
    exploit
    a Server Side Request Forgery (SSRF) attack to communicate over localhost, would be able to
    execute arbitrary
    code by passing in a logging config that contains python code.

    To remediate the issue, remove the call to `logging.config.listen` method.

    For more information on the listen functionality see:
    - https://docs.python.org/3/library/logging.config.html#logging.config.listen
  metadata:
    cwe: "CWE-94"
    shortDescription: "Improper control of generation of code ('Code Injection')"
    category: "security"
    license: "MIT"
    primary_identifier: "bandit.B612"
    secondary_identifiers:
    - name: "Bandit Test ID B612"
      type: "bandit_test_id"
      value: "B612"
  patterns:
  - pattern: "logging.config.listen(...)"
  severity: "WARNING"
- id: "bandit.B311"
  languages:
  - "python"
  message: |
    Depending on the context, generating weak random numbers may expose cryptographic functions,
    which rely on these numbers, to be exploitable. When generating numbers for sensitive values
    such as tokens, nonces, and cryptographic keys, it is recommended that the `secrets` module
    be used instead.

    Example using the secrets module:
    ```
    import secrets

    # Generate a secure random 64 byte array
    random_bytes = secrets.token_bytes(64)
    print(random_bytes)

    # Generate a secure random 64 byte array as a hex string
    random_bytes_hex = secrets.token_hex(64)

    # Generate a secure random 64 byte array base64 encoded for use in URLs
    random_string = secrets.token_urlsafe(64)
    ```

    For more information on the `secrets` module see:
    - https://docs.python.org/3/library/secrets.html
  metadata:
    cwe: "CWE-330"
    owasp: "A3:2017-Sensitive Data Exposure"
    category: "security"
    shortDescription: "Use of insufficiently random values"
    license: "MIT"
    primary_identifier: "bandit.B311"
    secondary_identifiers:
    - name: "Bandit Test ID B311"
      type: "bandit_test_id"
      value: "B311"
  pattern-either:
  - pattern: "random.random(...)"
  - pattern: "random.randrange(...)"
  - pattern: "random.randint(...)"
  - pattern: "random.choice(...)"
  - pattern: "random.uniform(...)"
  - pattern: "random.triangular(...)"
  severity: "INFO"
- id: "bandit.B113"
  languages:
  - "python"
  message: |
    The application was found using the `requests` module without configuring a timeout value for
    connections. This could lead to uncontrolled resource consumption where the application could
    run out of
    socket descriptors, effectively causing a Denial of Service (DoS).

    To remediate this issue, pass in a `timeout=` argument to each `requests` call.

    Example using a timeout for an HTTP GET request:
    ```
    # Issue a GET request to https://example.com with a timeout of 10 seconds
    response = requests.get('https://example.com', timeout=10)
    # Work with the response object
    # ...
    ```

    For more information on using the requests module see:
    - https://requests.readthedocs.io/en/latest/api/
  metadata:
    cwe: "CWE-400"
    category: "security"
    shortDescription: "Uncontrolled resource consumption"
    license: "MIT"
    primary_identifier: "bandit.B113"
    secondary_identifiers:
    - name: "Bandit Test ID B113"
      type: "bandit_test_id"
      value: "B113"
  patterns:
  - pattern-either:
    - patterns:
      - pattern: "requests.$METHOD('...', timeout=$VAL)"
      - metavariable-comparison:
          comparison: "$VAL <= 0"
          metavariable: "$VAL"
    - patterns:
      - pattern: "requests.$METHOD('...', timeout=$VAL)"
      - metavariable-regex:
          metavariable: "$VAL"
          regex: "(^None)"
    - patterns:
      - pattern-not: "requests.$METHOD('...', timeout=$VAL, ...)"
      - pattern-either:
        - pattern: "requests.$METHOD('...', ...)"
        - pattern: "requests.$METHOD('...')"
  - metavariable-regex:
      metavariable: "$METHOD"
      regex: "(get|put|delete|post|options|head|patch)"
  severity: "WARNING"
- id: "bandit.B106"
  languages:
  - "python"
  message: |
    Possible hardcoded password
  metadata:
    cwe: "CWE-259"
    owasp: "A3:2017-Sensitive Data Exposure"
    shortDescription: "Use of Hard-coded Password"
    license: "MIT"
    primary_identifier: "bandit.B106"
    secondary_identifiers:
    - name: "Bandit Test ID B106"
      type: "bandit_test_id"
      value: "B106"
  patterns:
  - pattern: "$FUNC(..., $PW=\"...\", ...)"
  - metavariable-regex:
      metavariable: "$PW"
      regex: ".*([Pp][Aa][Ss][Ss][Ww][Oo][Rr][Dd]|pass|passwd|pwd|secret|token|secrete).*"
  severity: "WARNING"
- id: "bandit.B105"
  languages:
  - "python"
  message: |
    Possible hardcoded password
  metadata:
    cwe: "CWE-259"
    owasp: "A3:2017-Sensitive Data Exposure"
    shortDescription: "Use of Hard-coded Password"
    license: "MIT"
    primary_identifier: "bandit.B105"
    secondary_identifiers:
    - name: "Bandit Test ID B105"
      type: "bandit_test_id"
      value: "B105"
  patterns:
  - pattern-either:
    - pattern: "$MASK == \"...\""
    - pattern: "$MASK = \"...\""
    - pattern: "$X[$MASK] = ..."
  - metavariable-regex:
      metavariable: "$MASK"
      regex: "[^\\[]*([Pp][Aa][Ss][Ss][Ww][Oo][Rr][Dd]|pass|passwd|pwd|secret|token|secrete)[^\\]]*"
  severity: "WARNING"
- id: "bandit.B508"
  languages:
  - "python"
  message: |
    Pysnmp was detected using versions SNMPv1 or SNMPv2. SNPMv1 and SNMPv2 are insecure
    and should no longer be used as they do not offer encryption.

    If possible, query SNMP devices using SNMPv3 instead.

    Example querying a device using SNMPv3 with SHA-AES:
    ```
    from pysnmp.hlapi import *
    # Create the snpm iterator
    iterator = getCmd(
        SnmpEngine(),
        # Configure using SHA AES
        UsmUserData('usr-sha-aes', 'authkey1', 'privkey1',
                    authProtocol=USM_AUTH_HMAC96_SHA,
                    privProtocol=USM_PRIV_CFB128_AES),
        UdpTransportTarget(('demo.snmplabs.com', 161)),
        ContextData(),
        ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0))
    )
    ```

    For more information on using SNMPv3 with `Pysnmp` see:
    - https://pysnmp.readthedocs.io/en/latest/examples/hlapi/v3arch/asyncore/sync/manager/cmdgen/snmp-versions.html#snmpv3-auth-sha-privacy-aes128
  metadata:
    cwe: "CWE-319"
    category: "security"
    shortDescription: "Cleartext transmission of sensitive information"
    license: "MIT"
    primary_identifier: "bandit.B508"
    secondary_identifiers:
    - name: "Bandit Test ID B508"
      type: "bandit_test_id"
      value: "B508"
  pattern-either:
  - pattern: "pysnmp.hlapi.CommunityData(..., mpModel=0, ...)"
  - pattern: "pysnmp.hlapi.CommunityData(..., mpModel=1, ...)"
  severity: "WARNING"
- id: "bandit.B509"
  languages:
  - "python"
  message: |
    Pysnmp was detected using SNMPv3 without authentication or encryption protections enabled.
    When calling `UsmUserData`, the first argument should be in the format of
    `usr-<authtype>-<encryption type>`.

    To remediate this issue, the `UsmUserData` should be configured with `usr-sha-aes` for
    SHA authentication and AES encryption.

    Example querying a device using SNMPv3 with SHA-AES:
    ```
    from pysnmp.hlapi import *
    # Create the snpm iterator
    iterator = getCmd(
        SnmpEngine(),
        # Configure using SHA AES
        UsmUserData('usr-sha-aes', 'authkey1', 'privkey1',
                    authProtocol=USM_AUTH_HMAC96_SHA,
                    privProtocol=USM_PRIV_CFB128_AES),
        UdpTransportTarget(('demo.snmplabs.com', 161)),
        ContextData(),
        ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0))
    )
    ```

    For more information on using SNMPv3 with `Pysnmp` see:
    - https://pysnmp.readthedocs.io/en/latest/examples/hlapi/v3arch/asyncore/sync/manager/cmdgen/snmp-versions.html#snmpv3-auth-sha-privacy-aes128
  metadata:
    cwe: "CWE-319"
    category: "security"
    shortDescription: "Cleartext Transmission of Sensitive Information"
    license: "MIT"
    primary_identifier: "bandit.B509"
    secondary_identifiers:
    - name: "Bandit Test ID B509"
      type: "bandit_test_id"
      value: "B509"
  pattern-either:
  - pattern: "pysnmp.hlapi.UsmUserData($ARG1, $ARG2)"
  - pattern: "pysnmp.hlapi.UsmUserData($ARG1)"
  - pattern: "pysnmp.hlapi.UsmUserData(...,'noAuthNoPriv',...)"
  - pattern: "pysnmp.hlapi.UsmUserData(...,'authNoPriv',...)"
  severity: "WARNING"
- id: "bandit.B502"
  languages:
  - "python"
  message: |
    The application was found calling an SSL module with SSL or TLS protocols that have known
    deficiencies.
    It is strongly recommended that newer applications use TLS 1.2 or 1.3 and
    `SSLContext.wrap_socket`.

    If using the `pyOpenSSL` module, please note that it has been deprecated and the Python
    Cryptographic Authority
    strongly suggests moving to use the [pyca/cryptography](https://github.com/pyca/cryptography)
    module instead.

    To remediate this issue for the `ssl` module, create a new TLS context and pass in
    `ssl.PROTOCOL_TLS_CLIENT` for clients or `ssl.PROTOCOL_TLS_SERVER` for servers to the
    `ssl.SSLContext(...)` `protocol=`
    argument. When converting the socket to a TLS socket, use the new `SSLContext.wrap_socket`
    method instead.

    Example creating a TLS 1.3 client socket connection by using a newer version of Python
    (3.11.4) and
    the SSL module:
    ```
    import ssl
    import socket

    # Create our initial socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        # Connect the socket
        sock.connect(('www.example.org', 443))

        # Create a new SSLContext with protocol set to ssl.PROTOCOL_TLS_CLIENT
        # This will auto-select the highest grade TLS protocol version (1.3)
        context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_CLIENT)
        # Load our a certificates for server certificate authentication
        context.load_verify_locations('cert.pem')
        # Create our TLS socket, and validate the server hostname matches
        with context.wrap_socket(sock, server_hostname="www.example.org") as tls_sock:
            # Send some bytes over the socket (HTTP request in this case)\
            data = bytes('GET / HTTP/1.1\r\nHost: example.org\r\n\r\n', 'utf-8')
            sent_bytes = tls_sock.send(data)
            # Validate number of sent bytes
            # ...
            # Read the response
            resp = tls_sock.recv()
            # Work with the response
            # ...
    ```

    For more information on the ssl module see:
    - https://docs.python.org/3/library/ssl.html

    For more information on pyca/cryptography and openssl see:
    - https://cryptography.io/en/latest/openssl/
  metadata:
    cwe: "CWE-326"
    owasp: "A3:2017-Sensitive Data Exposure"
    shortDescription: "Inadequate Encryption Strength"
    license: "MIT"
    primary_identifier: "bandit.B502"
    secondary_identifiers:
    - name: "Bandit Test ID B502"
      type: "bandit_test_id"
      value: "B502"
  patterns:
  - pattern-either:
    - pattern: "ssl.PROTOCOL_SSLv2"
    - pattern: "ssl.PROTOCOL_SSLv3"
    - pattern: "ssl.PROTOCOL_TLSv1"
    - pattern: "ssl.PROTOCOL_TLSv1_1"
    - pattern: "pyOpenSSL.SSL.SSLv2_METHOD"
    - pattern: "pyOpenSSL.SSL.SSLv23_METHOD"
    - pattern: "pyOpenSSL.SSL.SSLv3_METHOD"
    - pattern: "pyOpenSSL.SSL.TLSv1_METHOD"
    - pattern: "pyOpenSSL.SSL.TLSv1_1_METHOD"
  severity: "ERROR"
- id: "bandit.B401"
  languages:
  - "python"
  message: |
    The application was found using a telnet library. As telnet does not provide encryption, it is
    strongly recommended that communications use a more secure transport such as
    SSH.

    The [paramiko](https://www.paramiko.org/) library can be used to initiate SSH connections.

    Example using `paramiko` SSH client:
    ```
    import paramiko
    import scp

    # Create an SSH client
    with paramiko.SSHClient() as ssh:
        # Load the system host keys so we can confirm the
        # host we are connecting to is legitimate
        ssh.load_system_host_keys('/home/appuser/.ssh/known_hosts')

        # Connect to the remote host using our SSH private key
        ssh.connect(hostname='example.org',
                    port=22,
                    username='appuser',
                    key_filename='/home/appuser/.ssh/private_key')
        # Work with the connection
    ```

    For more information on the paramiko module see:
    - https://www.paramiko.org/
  metadata:
    cwe: "CWE-319"
    category: "security"
    owasp: "A3:2017-Sensitive Data Exposure"
    shortDescription: "Cleartext transmission of sensitive information"
    license: "MIT"
    primary_identifier: "bandit.B401"
    secondary_identifiers:
    - name: "Bandit Test ID B401"
      type: "bandit_test_id"
      value: "B401"
  patterns:
  - pattern: "import telnetlib"
  severity: "ERROR"
- id: "bandit.B312"
  languages:
  - "python"
  message: |
    Telnet does not encrypt communications. Use SSH instead.
  metadata:
    cwe: "CWE-319"
    owasp: "A3:2017-Sensitive Data Exposure"
    shortDescription: "Cleartext Transmission of Sensitive Information"
    license: "MIT"
    primary_identifier: "bandit.B312"
    secondary_identifiers:
    - name: "Bandit Test ID B312"
      type: "bandit_test_id"
      value: "B312"
  pattern: "telnetlib.$ANYTHING(...)"
  severity: "WARNING"
- id: "bandit.B108-2"
  languages:
  - "python"
  message: |
    Probable insecure usage of temp file/directory.
  metadata:
    cwe: "CWE-377"
    shortDescription: "Insecure Temporary File"
    license: "MIT"
    primary_identifier: "bandit.B108-2"
    secondary_identifiers:
    - name: "Bandit Test ID B108"
      type: "bandit_test_id"
      value: "B108"
  patterns:
  - pattern: "open($DIR, ...)"
  - metavariable-regex:
      metavariable: "$DIR"
      regex: "['\"](/tmp|/var/tmp|/dev/shm).*['\"]"
  severity: "WARNING"
- id: "bandit.B310-2"
  languages:
  - "python"
  message: |
    Detected a dynamic value being used with urllib. urllib supports `file://` schemes, so a
    dynamic value controlled by a malicious actor may allow them to read arbitrary files. Audit
    uses of urllib calls to ensure user data cannot control the URLs, or consider using the
    `requests` library instead.
  metadata:
    cwe: "CWE-939"
    owasp: "A5:2017-Broken Access Control"
    shortDescription: "Improper Authorization in Handler for Custom URL Scheme"
    license: "MIT"
    primary_identifier: "bandit.B310-2"
    secondary_identifiers:
    - name: "Bandit Test ID B310"
      type: "bandit_test_id"
      value: "B310"
  pattern-either:
  - pattern: "urllib.urlopen(...)"
  - pattern: "urllib2.urlopen(...)"
  - pattern: "urllib2.Request(...)"
  - pattern: "urllib.Request(...)"
  - pattern: "urllib.URLopener(...)"
  - pattern: "urllib.FancyURLopener(...)"
  - pattern: "urllib.request.FancyURLopener(...)"
  - pattern: "urllib.request.urlopen(...)"
  - pattern: "urllib.request.URLopener(...)"
  - pattern: "urllib.request.urlretrieve(...)"
  - pattern: "six.moves.urllib.request.urlopen(...)"
  - pattern: "six.moves.urllib.request.urlretrieve(...)"
  - pattern: "six.moves.urllib.request.URLopener(...)"
  - pattern: "six.moves.urllib.request.FancyURLopener(...)"
  severity: "WARNING"
- id: "bandit.B313"
  languages:
  - "python"
  message: |
    The application was found using the `xml.etree` package for processing XML.
    Pythons default xml processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `etree` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B313"
    secondary_identifiers:
    - name: "Bandit Test ID B313"
      type: "bandit_test_id"
      value: "B313"
  pattern-either:
  - patterns:
    - pattern: "xml.etree.cElementTree.fromstring(...)"
    - pattern-not: "xml.etree.cElementTree.fromstring(\"...\")"
  - pattern: "xml.etree.cElementTree.parse(...)"
  - pattern: "xml.etree.cElementTree.iterparse(...)"
  - pattern: "xml.etree.cElementTree.XMLParser(...)"
  severity: "WARNING"
- id: "bandit.B314"
  languages:
  - "python"
  message: |
    The application was found using the `xml.etree` package for processing XML.
    Pythons default xml processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `etree` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B314"
    secondary_identifiers:
    - name: "Bandit Test ID B314"
      type: "bandit_test_id"
      value: "B314"
  pattern-either:
  - patterns:
    - pattern: "xml.etree.ElementTree.fromstring(...)"
    - pattern-not: "xml.etree.ElementTree.fromstring(\"...\")"
  - pattern: "xml.etree.ElementTree.parse(...)"
  - pattern: "xml.etree.ElementTree.iterparse(...)"
  - pattern: "xml.etree.ElementTree.XMLParser(...)"
  severity: "WARNING"
- id: "bandit.B320"
  languages:
  - "python"
  message: |
    The application was found using the `lxml.etree` package for processing XML.
    Python's default XML processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `etree` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B320"
    secondary_identifiers:
    - name: "Bandit Test ID B320"
      type: "bandit_test_id"
      value: "B320"
  pattern-either:
  - pattern: "lxml.etree.parse(...)"
  - patterns:
    - pattern: "lxml.etree.fromstring(...)"
    - pattern-not: "lxml.etree.fromstring(\"...\")"
  - pattern: "lxml.etree.RestrictedElement(...)"
  - pattern: "lxml.etree.GlobalParserTLS(...)"
  - pattern: "lxml.etree.getDefaultParser(...)"
  - pattern: "lxml.etree.check_docinfo(...)"
  severity: "WARNING"
- id: "bandit.B316"
  languages:
  - "python"
  message: |
    The application was found using the `xml.dom.expatbuilder` which calls the `xml.dom.minidom`
    package for processing XML. Python's default XML processors suffer from various XML parsing
    vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `xml.dom.minidom` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B316"
    secondary_identifiers:
    - name: "Bandit Test ID B316"
      type: "bandit_test_id"
      value: "B316"
  pattern-either:
  - patterns:
    - pattern: "xml.dom.expatbuilder.parse(...)"
    - pattern-not: "xml.dom.expatbuilder.parse(\"...\")"
  - pattern: "xml.dom.expatbuilder.parseString(...)"
  severity: "WARNING"
- id: "bandit.B315"
  languages:
  - "python"
  message: |
    The application was found using the `xml.sax.expatreader` package for processing XML. Python's
    default XML processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `xml.sax` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B315"
    secondary_identifiers:
    - name: "Bandit Test ID B315"
      type: "bandit_test_id"
      value: "B315"
  pattern-either:
  - pattern: "xml.dom.expatreader.parse(...)"
  - patterns:
    - pattern: "xml.dom.expatreader.parseString(...)"
    - pattern-not: "xml.dom.expatreader.parseString(\"...\")"
  - pattern: "xml.dom.expatreader.parseString(...)"
  - pattern: "xml.dom.expatreader.create_parser(...)"
  severity: "WARNING"
- id: "bandit.B405"
  languages:
  - "python"
  message: |
    Consider possible security implications associated with etree module.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B405"
    secondary_identifiers:
    - name: "Bandit Test ID B405"
      type: "bandit_test_id"
      value: "B405"
  patterns:
  - pattern-either:
    - pattern: "import xml.etree.cElementTree"
    - pattern: "import xml.etree.ElementTree"
  severity: "INFO"
- id: "bandit.B407"
  languages:
  - "python"
  message: |
    Using various methods to parse untrusted XML data is known to be vulnerable to
    XML attacks. Replace vulnerable imports with the equivalent defusedxml package,
    or make sure defusedxml.defuse_stdlib() is called.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B407"
    secondary_identifiers:
    - name: "Bandit Test ID B407"
      type: "bandit_test_id"
      value: "B407"
  patterns:
  - pattern-either:
    - pattern: "import xml.dom.expatbuilder"
  severity: "INFO"
- id: "bandit.B410"
  languages:
  - "python"
  message: |
    Using various methods to parse untrusted XML data is known to be vulnerable to
    XML attacks. Replace vulnerable imports with the equivalent defusedxml package.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B410"
    secondary_identifiers:
    - name: "Bandit Test ID B410"
      type: "bandit_test_id"
      value: "B410"
  patterns:
  - pattern-either:
    - pattern: "import lxml"
  severity: "INFO"
- id: "bandit.B408"
  languages:
  - "python"
  message: |
    Using various methods to parse untrusted XML data is known to be vulnerable
    to XML attacks. Replace vulnerable imports with the equivalent defusedxml
    package, or make sure defusedxml.defuse_stdlib() is called.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B408"
    secondary_identifiers:
    - name: "Bandit Test ID B408"
      type: "bandit_test_id"
      value: "B408"
  patterns:
  - pattern-either:
    - pattern: "import xml.dom.minidom"
  severity: "INFO"
- id: "bandit.B403"
  languages:
  - "python"
  message: |
    Consider possible security implications associated with pickle module.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B403"
    secondary_identifiers:
    - name: "Bandit Test ID B403"
      type: "bandit_test_id"
      value: "B403"
  patterns:
  - pattern-either:
    - pattern: "import pickle"
    - pattern: "import cPickle"
    - pattern: "import dill"
  severity: "INFO"
- id: "bandit.B409"
  languages:
  - "python"
  message: |
    Using various methods to parse untrusted XML data is known to be vulnerable to
    XML attacks. Replace vulnerable imports with the equivalent defusedxml package,
    or make sure defusedxml.defuse_stdlib() is called.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B409"
    secondary_identifiers:
    - name: "Bandit Test ID B409"
      type: "bandit_test_id"
      value: "B409"
  patterns:
  - pattern-either:
    - pattern: "import xml.dom.pulldom"
  severity: "INFO"
- id: "bandit.B406"
  languages:
  - "python"
  message: |
    Using various methods to parse untrusted XML data is known to be vulnerable to
    XML attacks. Replace vulnerable imports with the equivalent defusedxml package,
    or make sure defusedxml.defuse_stdlib() is called.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B406"
    secondary_identifiers:
    - name: "Bandit Test ID B406"
      type: "bandit_test_id"
      value: "B406"
  patterns:
  - pattern-either:
    - pattern: "import xml.sax"
  severity: "INFO"
- id: "bandit.B411"
  languages:
  - "python"
  message: |
    Consider possible security implications associated with xmlrpclib module.
  metadata:
    cwe: "CWE-502"
    owasp: "A8:2017-Insecure Deserialization"
    shortDescription: "Deserialization of Untrusted Data"
    license: "MIT"
    primary_identifier: "bandit.B411"
    secondary_identifiers:
    - name: "Bandit Test ID B411"
      type: "bandit_test_id"
      value: "B411"
  pattern-either:
  - pattern: "import xmlrpclib"
  severity: "ERROR"
- id: "bandit.B318"
  languages:
  - "python"
  message: |
    The application was found using the `xml.dom.minidom` package for processing XML. Python's
    default XML processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `xml.dom.minidom` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B318"
    secondary_identifiers:
    - name: "Bandit Test ID B318"
      type: "bandit_test_id"
      value: "B318"
  pattern-either:
  - patterns:
    - pattern: "xml.dom.minidom.parseString(...)"
    - pattern-not: "xml.dom.minidom.parseString(\"...\")"
  - pattern: "xml.dom.minidom.parse(...)"
  severity: "WARNING"
- id: "bandit.B319"
  languages:
  - "python"
  message: |
    The application was found using the `xml.dom.pulldom` package for processing XML. Python's
    default XML processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `xml.dom.pulldom` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper Restriction of XML External Entity Reference"
    license: "MIT"
    primary_identifier: "bandit.B319"
    secondary_identifiers:
    - name: "Bandit Test ID B319"
      type: "bandit_test_id"
      value: "B319"
  pattern-either:
  - patterns:
    - pattern: "xml.dom.pulldom.parseString(...)"
    - pattern-not: "xml.dom.pulldom.parseString(\"...\")"
  - pattern: "xml.dom.pulldom.parse(...)"
  severity: "WARNING"
- id: "bandit.B317"
  languages:
  - "python"
  message: |
    The application was found using the `xml.sax` package for processing XML.
    Python's default XML processors suffer from various XML parsing vulnerabilities
    and care must be taken when handling XML data. Additionally, depending on the
    version of Python, more critical vulnerabilities such as eXternal XML Entity
    injection maybe exploitable.

    The `xml.sax` package suffers from the following security risks as of Python 3.7.1:
    * Billion laughs / exponential entity expansion - May allow an adversary to cause
      a Denial of Service (DoS) against the application parsing arbitrary XML.
    * Quadratic blowup entity expansion - Similar to above, but requires a larger input
      to cause the Denial of Service.

    To remediate the above issues, consider using the
    [defusedxml](https://pypi.org/project/defusedxml/)
    library when processing untrusted XML.

    Example parsing an XML document using defusedxml:
    ```
    from defusedxml.ElementTree import parse

    # Parse the inventory.xml file
    et = parse('inventory.xml')
    # Get the root element
    root = et.getroot()
    # Work with the root element
    # ...
    ```

    For more information on the various XML parsers and their vulnerabilities please see:
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities

    For more information on XML security see OWASP's guide:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#python
  metadata:
    cwe: "CWE-611"
    owasp: "A4:2017-XML External Entities (XXE)"
    category: "security"
    shortDescription: "Improper restriction of XML external entity reference"
    license: "MIT"
    primary_identifier: "bandit.B317"
    secondary_identifiers:
    - name: "Bandit Test ID B317"
      type: "bandit_test_id"
      value: "B317"
  pattern-either:
  - pattern: "xml.sax.parse(...)"
  - patterns:
    - pattern: "xml.sax.parseString(...)"
    - pattern-not: "xml.sax.parseString(\"...\")"
  - pattern: "xml.sax.make_parser(...)"
  severity: "WARNING"
